# 💡 Идеи за подобряване на unified_bom_viewer.html

Този документ съдържа идеи, предложения и дискусии за бъдещи подобрения на BOM визуализатора.

---

## 🏭 Идея #1: Администраторски и потребителски режим + Класификация "Цех vs На обекта"

**Дата:** 10 декември 2024  
**Статус:** 💭 В дискусия

### 📝 Оригинален въпрос от потребителя

> Сега искам да внедрим от "bom_classifier" функцията за питане дали се сглобява "тук" или "на обекта", която функция касае отделни възли от даден проект. Но също така ще искам освен да я пренесем от bom_classifier в нашият html, който работи, то и да го подобрим като направим два "панела", един администраторски, който да може да прави промени по нещата в таблиците, например в РАЛ графата и да задава кое се сглобява "тук" и кое "на обекта" и един "потребителски", който да служи за всички, които трябва да гледат таблиците, но да имат по-ограничени функции.
> 
> Разгледай логиката за функцията за задаване на това къде се сглобява в другият html файл и след това ми дай идеи как можем да направим горните две неща, за да може да го обсъдим, да ги помислим и чак тогава да прибегнем към изпълнение.

---

## 📊 Анализ на съществуващата функционалност в `bom_classifier.html`

### Как работи класификацията "Цех vs На обекта":

1. **Интерактивен процес:**
   - Показва всяка сборка една по една
   - Два бутона: "✅ ДА - Сглобява се в цеха" / "❌ НЕ - Сглобява се на обекта"
   - Автоматична класификация на подсборки (ако родител е "Цех", децата също)

2. **Съхранение:**
   - Два масива: `workshopItems[]` и `externalItems[]`
   - Два Set-а: `workshopPaths` и `externalPaths`
   - Експорт в JSON файл с резултатите

3. **Визуализация:**
   - Два панела с класифицирани елементи
   - Брояч на всяка категория
   - Финален отчет с детайлни таблици

---

## 💡 ИДЕИ за имплементация в `unified_bom_viewer.html`

**СТАТУС:** 🚀 В процес на имплементация (Фаза 1 завършена)

### **Вариант 1: Два режима (Админ + Потребител) със switch бутон**

```
┌─────────────────────────────────────────┐
│  [👤 Потребител] ⟷ [👨‍💼 Администратор]   │  ← Toggle switch
└─────────────────────────────────────────┘

ПОТРЕБИТЕЛСКИ РЕЖИМ:
- Само четене на данни
- Вижда таблиците с read-only полета
- Няма бутони за редакция
- Може да експортира PDF/Excel

АДМИНИСТРАТОРСКИ РЕЖИМ:
- Пълен достъп за редакция
- Dropdown за всяка сборка: [Цех ▼] / [Обект ▼]
- Inline редакция на RAL цветове
- Бутон "💾 Запази промените" → localStorage/JSON
```

**Плюсове:** Лесно превключване, един файл  
**Минуси:** Няма автентикация, всеки може да влезе в админ режим

---

### **Вариант 2: Два отделни HTML файла**

```
unified_bom_viewer.html        ← Потребителски (read-only)
unified_bom_admin.html         ← Администраторски (с редакция)
```

**Плюсове:** Ясно разделение, може да се защити админ файла  
**Минуси:** Дублиране на код, по-сложна поддръжка

---

### **Вариант 3: Парола за админ режим**

```
┌─────────────────────────────────────────┐
│  [🔓 Отключи администраторски режим]     │  ← Бутон
└─────────────────────────────────────────┘
           ↓ (клик)
┌─────────────────────────────────────────┐
│  Въведи парола: [__________] [OK]       │  ← Modal
└─────────────────────────────────────────┘
           ↓ (ако правилна)
┌─────────────────────────────────────────┐
│  🔓 АДМИНИСТРАТОРСКИ РЕЖИМ АКТИВЕН       │
│  + Dropdown-и за класификация            │
│  + RAL редактор                          │
└─────────────────────────────────────────┘
```

**Плюсове:** Просто, в един файл, с минимална защита  
**Минуси:** Паролата е в JS кода (лесно се вижда в source)

---

## 🎨 Предложение за UI/UX на класификацията

### **Къде да поставим функцията?**

#### **Опция A: Нова колона в "Дърво на детайлите"**
```
┌──────┬─────────────┬─────────────┬──────────────┬────────────┐
│ Ниво │ Възел       │ Име         │ Сглобяване   │ Количество │
├──────┼─────────────┼─────────────┼──────────────┼────────────┤
│  1   │ ALL Bufer.. │ 30_03_S1    │ [Цех ▼]      │ 1          │
│  1   │ ALL Bufer.. │ Planka Buf..│ [Обект ▼]    │ 1          │
└──────┴─────────────┴─────────────┴──────────────┴────────────┘
                                      ↑
                                    Dropdown само в админ режим
```

#### **Опция B: Нов таб "🏭 Класификация"**
```
[Преглед] [Дърво на детайлите] [🏭 Класификация] [Всички части] ...
                                        ↓
    ┌─────────────────────────────────────────┐
    │  🏭 Сглобява се в цеха (12 сборки)      │
    │  ✓ ALL Bufer Service Komplekt           │
    │  ✓ Anker M10x80 Komplekt                │
    │  ...                                    │
    ├─────────────────────────────────────────┤
    │  🏗️ Сглобява се на обекта (5 сборки)   │
    │  ✓ Planka Bufer Komplekt                │
    │  ...                                    │
    └─────────────────────────────────────────┘
    
    В админ режим: Бутони за преместване между категории
```

#### **Опция C: Modal диалог с wizard**
```
[Бутон: 🏭 Класифицирай сборки] → Modal
    ↓
┌───────────────────────────────────────────┐
│  Сборка 1 от 12: ALL Bufer Service..      │
│  [Снимка]                                 │
│                                           │
│  Къде се сглобява?                        │
│  [🏭 В цеха]  [🏗️ На обекта]             │
│                                           │
│  [← Назад]  [Прескочи]  [Напред →]        │
└───────────────────────────────────────────┘
```

---

## 🗄️ Съхранение на данните

### **Вариант 1: localStorage (Browser)**
```javascript
// Запазване
const classificationData = {
    workshopAssemblies: ['ALL Bufer Service Komplekt', ...],
    externalAssemblies: ['Planka Bufer Komplekt', ...],
    ralColors: {'30_03_S1': 'RAL9005', ...},
    timestamp: '2024-12-09T10:30:00'
};
localStorage.setItem('bomClassification', JSON.stringify(classificationData));

// Зареждане
const saved = JSON.parse(localStorage.getItem('bomClassification'));
```

**Плюсове:** Лесно, няма server  
**Минуси:** Локално на компютъра, не се синхронизира

### **Вариант 2: JSON файл**
```javascript
// Експорт
function exportClassification() {
    const data = { /* ... */ };
    const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'bom_classification.json';
    a.click();
}

// Импорт
<input type="file" accept=".json" onchange="importClassification(event)">
```

**Плюсове:** Може да се споделя между компютри  
**Минуси:** Ръчен процес на импорт/експорт

### **Вариант 3: Разширен bom_data.json**
Добавяме ново поле в съществуващия JSON:
```json
{
  "objects": [...],
  "classification": {
    "workshopAssemblies": ["ALL Bufer Service Komplekt"],
    "externalAssemblies": ["Planka Bufer Komplekt"],
    "ralColors": {"30_03_S1": "RAL9005"}
  }
}
```

---

## 🎯 КОНКРЕТНО ПРЕДЛОЖЕНИЕ

### **Хибриден подход:**

1. **Режими:** Toggle switch [Потребител ⟷ Администратор] със **проста парола**
2. **UI:** Нова колона "Сглобяване" в таба "Дърво на детайлите" + отделен таб "🏭 Класификация"
3. **Съхранение:** localStorage + експорт/импорт JSON файл
4. **RAL редакция:** Inline редактор в админ режим

### **Стъпки за имплементация:**

**Фаза 1:** Основна структура
- Добавяне на toggle switch за режими
- Проста парола (хардкодирана в началото)
- Нова колона "Сглобяване" в таблицата

**Фаза 2:** Класификация
- Dropdown [Цех/Обект/Неопределен] само в админ режим
- Автоматична класификация на подсборки
- localStorage за запазване

**Фаза 3:** Визуализация
- Нов таб "🏭 Класификация" с два списъка
- Филтриране по категория
- Брояч на елементи

**Фаза 4:** RAL & Експорт
- Inline RAL редактор
- Експорт/импорт на класификацията
- Финален отчет (като в bom_classifier)

---

## ❓ Въпроси за дискусия:

1. **Кой вариант за режими предпочиташ?** (Switch / Отделни файлове / Парола)
2. **Къде да покажем класификацията?** (Нова колона / Нов таб / Modal)
3. **Автоматична класификация?** Ако родител е "Цех", децата също ли да са "Цех"?
4. **RAL редакция:** Inline в таблицата или отделен modal?
5. **Паролата:** Хардкодирана в JS или нещо по-сложно?

---

## 📌 Статус

- [x] Обсъдено с потребителя
- [x] Избрани конкретни варианти
- [ ] Планиране на фази
- [ ] Започната имплементация

---

## ✅ ФИНАЛНИ РЕШЕНИЯ (10 декември 2024)

### **Решение 1: Режими (Въпрос 1)**
✅ **Toggle switch + парола "2006"**
- В горния десен ъгъл: Toggle `[👤 Потребител] ⟷ [👨‍💼 Администратор]`
- При клик на "Администратор" → modal с парола
- Парола: `2006` (хардкодирана в JS)
- Цел: Психологическа бариера срещу случайни промени

### **Решение 2: UI/UX (Въпрос 2)**
✅ **Нов таб "🏭 Сглобяване" между "Крепежи" и "RAL елементи"**
- Структура на табовете: `[...] [Крепежи] [🏭 Сглобяване] [RAL елементи]`
- Вътре две секции:
  - 🏭 Сглобяване в цеха
  - 🏗️ Сглобяване на обекта
- Йерархично дърво с **[+]** бутони за expand/collapse
- Бутони **[→ Премести]** до всеки елемент (само в админ режим)

### **Решение 3: Автоматична класификация (Въпрос 3)**
✅ **Wizard пита само level 1, останалите наследяват + независими промени**

**Начална класификация:**
1. Modal wizard се отваря с бутон "🏭 Започни класификация"
2. Показва само **главни сборки (level 1)** една по една
3. Два бутона: `[🏭 Цех]` `[🏗️ Обект]`
4. Всички подсборки (level 2+) **автоматично наследяват** категорията на родителя

**Ръчна промяна:**
- След класификацията в таба "🏭 Сглобяване" има бутони **[→ Премести]**
- Всяка подсборка може да се премести **независимо** от родителя
- При промяна се показва **визуална връзка** със следа

### **Решение 4: Визуална връзка при независима класификация**
✅ **Комбинация: Икона + Tooltip + Read-only списък**

**Пример:**
```
🏭 Сглобяване в цеха (12 сборки)

  [+] Planka Bufer Komplekt (3 елемента)                    [→ На обекта]
      🔧 Детайли:
          Буфер                     1 бр    [→ На обекта]
      🏗️ Подсборки:
          M12x30 Komplekt           1 бр    [→ На обекта]
      
      ⚠️ СВЪРЗАНИ ЧАСТИ НА ОБЕКТА (read-only):
          🔗 M8x20 Komplekt         2 бр    [👁️ Виж]
                                              ↑
                                        Scroll до обекта
```

**Визуални елементи:**
1. **⚠️ Икона** до името на подсборката (за видимост)
2. **Tooltip** при hover с пълна информация
3. **Read-only секция** в сиво с всички свързани части
4. **Бутон [👁️ Виж]** → scroll + highlight родителя за 3 секунди

### **Решение 5: Как работи "Виж" функцията**
✅ **Scroll + Highlight**
1. Scroll-ва до родителската сборка в същия таб
2. Highlight-ва родителя с цветна рамка за 3 секунди
3. Анимация за плавен преход

### **Решение 6: Къде да се съхраняват данните**
✅ **localStorage + експорт/импорт JSON**
- Основно: `localStorage` на браузъра
- Експорт: Бутон "📥 Експорт JSON" → изтегля файл
- Импорт: Бутон "📤 Импорт JSON" → зарежда файл
- Формат: 
```json
{
  "workshopAssemblies": ["ALL Bufer Service Komplekt", ...],
  "externalAssemblies": ["Planka Bufer Komplekt", ...],
  "timestamp": "2024-12-10T10:30:00"
}
```

---

## 🚀 ПЛАН ЗА ИМПЛЕМЕНТАЦИЯ

### **Фаза 1: Основна структура (1-2 часа)** ✅ ЗАВЪРШЕНА
**Цел:** Toggle switch + парола + админ индикатор

**Задачи:**
1. ✅ Добавяне на CSS стилове за toggle switch и modal (~570 реда)
2. ✅ HTML елементи за toggle switch в header-а
3. ✅ JavaScript функции:
   - ✅ `toggleAdminMode()` - превключва между режими
   - ✅ `showPasswordModal()` - показва modal за парола
   - ✅ `validatePassword()` - проверява парола "2006"
   - ✅ `updateUIForAdminMode()` - контролира admin контроли
4. ✅ localStorage за запомняне на режима
5. ✅ Защита на RAL редакция с `admin-only-control` класове

**Резултат:** ✅ Потребителят може да влезе в админ режим с парола, RAL полетата са защитени

**Документация:** Интеграция #7 в `integration_log.md`

---

### **Фаза 2: Нов таб "🏭 Сглобяване" + localStorage (2-3 часа)** ✅ ЗАВЪРШЕНА
**Цел:** Основна структура на таба и съхранение

**Задачи:**
1. ✅ Добавяне на таб бутон между "Крепежи" и "RAL елементи"
2. ✅ HTML структура на таба:
   - ✅ Секция "🏭 Сглобяване в цеха"
   - ✅ Секция "🏗️ Сглобяване на обекта"
   - ✅ Бутони за управление (admin-only)
   - ✅ Информационно съобщение за user режим
3. ✅ CSS стилове (~100 реда):
   - ✅ `.classification-section`, `.empty-classification`
   - ✅ `.assembly-item`, `.move-button`
   - ✅ Различни цветове за workshop/external
4. ✅ JavaScript функции (~200+ реда):
   - ✅ `loadAssemblyClassification()` - зарежда от мрежата/localStorage
   - ✅ `saveAssemblyClassification(data)` - запазва чрез saveUserDataChange()
   - ✅ `generateAssemblyClassificationTab()` - генерира HTML
   - ✅ `findAssemblyByPath(path)` - помощна функция
   - ✅ Placeholder функции за Фази 3-6
5. ✅ Интеграция с admin режим и мрежова инфраструктура
6. ✅ Празно състояние с инструкции

**Резултат:** ✅ Таб "🏭 Сглобяване" с красиво празно състояние, готов за класификация

**Документация:** Интеграция #8 в `integration_log.md`

---

### **Фаза 3: Modal wizard за класификация (3-4 часа)** ⏳ СЛЕДВАЩА
**Цел:** Първоначална класификация само на level 1 сборки

**Задачи:**
1. Modal wizard UI:
   - Заглавие: "Сборка X от Y"
   - Снимка на сборката (ако има)
   - Име на сборката
   - Два големи бутона: `[🏭 В цеха]` `[🏗️ На обекта]`
   - Навигация: `[← Назад]` `[Прескочи]` `[Напред →]`
2. JavaScript функции:
   - `startClassificationWizard()` - стартира wizard-а
   - `getLevel1Assemblies()` - извлича само level 1 сборки
   - `classifyAssembly(assemblyPath, category)` - класифицира сборка
   - `autoClassifyChildren(parentPath, category)` - автоматично класифицира деца
   - `showNextAssembly()` - показва следващата сборка
   - `completeClassification()` - завършва wizard-а
3. Автоматична класификация на подсборки (level 2+)
4. Прогрес бар (опционално)

**Резултат:** Потребителят може бързо да класифицира всички главни сборки

---

### **Фаза 4: Йерархично дърво с expand/collapse (4-5 часа)**
**Цел:** Визуализация с [+] бутони и [→ Премести] функционалност

**Задачи:**
1. HTML генериране на йерархично дърво:
   - Главна сборка с `[+]` бутон
   - При expand → детайли и подсборки
   - Подсборки също имат `[+]` ако имат деца (level 3)
2. CSS стилове:
   - Индентация за йерархия
   - Expand/collapse анимация
   - Hover ефекти
3. JavaScript функции:
   - `toggleAssemblyExpand(assemblyId)` - разгъва/сгъва сборка
   - `loadAssemblyChildren(assemblyPath)` - зарежда деца от flatBOM
   - `renderAssemblyTree(assemblies, category)` - генерира дървото
4. Бутони `[→ Премести]` в админ режим:
   - `moveAssembly(assemblyPath, fromCategory, toCategory)`
   - Refresh на двете секции

**Резултат:** Пълна визуализация на класификацията с възможност за редакция

---

### **Фаза 5: Визуална връзка при независима класификация (3-4 часа)**
**Цел:** ⚠️ Икона + Tooltip + Read-only списък + [👁️ Виж] функция

**Задачи:**
1. Функция за откриване на "сирачета":
   - `findOrphanAssemblies(assemblyPath)` - намира подсборки в друга категория
   - `findParentAssembly(assemblyPath)` - намира родителя
2. HTML генериране на "следата":
   - ⚠️ Икона до името
   - Tooltip с текст: "Част от [Parent] (в цеха)"
   - Read-only секция със свързани части
   - Бутон `[👁️ Виж]`
3. CSS стилове:
   - `.assembly-trace` - сива секция
   - `.assembly-orphan-icon` - ⚠️ икона
   - `.assembly-trace-tooltip` - tooltip стил
4. JavaScript функции:
   - `showAssemblyTrace(assemblyPath)` - генерира следата
   - `scrollToAssembly(assemblyPath)` - scroll + highlight
   - `highlightAssembly(element)` - анимация за 3 секунди

**Резултат:** Ясна визуална връзка между родител и деца в различни категории

---

### **Фаза 6: Експорт/Импорт + Финализация (2-3 часа)**
**Цел:** Експорт в JSON, импорт от JSON, полиране

**Задачи:**
1. Експорт функционалност:
   - `exportClassification()` - генерира JSON файл
   - Формат: `{workshopAssemblies, externalAssemblies, timestamp}`
2. Импорт функционалност:
   - `<input type="file" accept=".json">` бутон
   - `importClassification(file)` - зарежда JSON
   - Валидация на структурата
3. Бутони в админ режим:
   - `[💾 Запази в localStorage]`
   - `[📥 Експорт JSON]`
   - `[📤 Импорт JSON]`
4. Полиране:
   - Notification-и при успех/грешка
   - Confirmation диалози при критични действия
   - Tooltips с инструкции

**Резултат:** Пълна функционалност за класификация с възможност за споделяне

---

## 📋 ОБЩ TIMELINE

**Общо време:** 15-21 часа разработка

**Разпределение:**
- Фаза 1: 1-2 часа
- Фаза 2: 2-3 часа
- Фаза 3: 3-4 часа
- Фаза 4: 4-5 часа
- Фаза 5: 3-4 часа
- Фаза 6: 2-3 часа

**Препоръчан подход:**
- Работа на фази, тестване след всяка фаза
- Документиране в `integration_log.md` след всяка фаза
- Commit в git (ако се използва) след всяка фаза

**Готови за старт?** 🚀

---

## 🌐 Идея #2: Мрежов режим и споделяне на данни

**Дата:** 10 декември 2025  
**Статус:** ✅ Вече имплементирано и работещо

### 📝 Описание

Файлът **вече разполага** с пълна инфраструктура за мрежов режим и споделяне на данни в реално време между потребители.

### ✅ Какво е налично:

**1. Автоматично откриване:**
- `detectSharedMode()` - проверява за сървър при зареждане
- Визуален индикатор в горен десен ъгъл (🟢 Мрежов / 🔴 Локален)

**2. API endpoints:**
```
POST /save_user_data  - запазва промени
GET  /get_user_data   - зарежда данни
```

**3. Dual storage:**
- Мрежов режим → изпраща към сървър
- Локален режим → localStorage fallback

**4. Real-time sync:**
- Всяка промяна се запазва веднага
- Споделя се между всички потребители

**5. Вече работи за:**
- ✅ Checkboxes (отметнати части)
- ✅ Бележки към части
- ✅ RAL цветове

### 🔮 За бъдещите функции:

**Класификацията "Цех vs На обекта" (Фази 2-6) автоматично ще използва тази инфраструктура:**

```javascript
// Запазване на класификация:
await saveUserDataChange('classification_' + assemblyPath, category);

// Зареждане на всички класификации:
const data = await loadSharedUserData();
```

**Не се изисква допълнителна работа за мрежовата функционалност!** 🎯

---
---

